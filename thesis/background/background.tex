\chapter{Background}

\label{ch:background}

We will cover how deep symbolic reinforcement learning extracts symbolic representations from raw input data, which will motivate a discussion of loss functions and the introduction of autoencoders. Seeing the limitations of the current approach in extracting symbolic representations, we can appreciate the recent development of $\beta$-VAE, a variant of the variational autoencoder used to learn disentangled representations. Finally, we can conclude by mentioning less technical matters, such as libraries and hardware used.

%
%
%
%
%
\section{Loss functions}

The idea of image reconstruction plays a vital role throughout this project. Although it's possible to qualitatively compare the original to its reconstruction, it's important to be able to quantify the difference, which lends itself to automation. The loss function will quantify how similar two images are.

To compare loss functions, we'll use the MNIST data set. MNIST is a collection of $70,000$ black-and-white images of handwritten digits, with $60,000$ in the training set containing and $10,000$ in the test set. These images will be represented as vectors without loss of generality.

\subsection{Euclidean Distance}

The Euclidean distance between two vectors $\vec{x}$ and $\vec{y}$ is defined by $$\sqrt{\sum_{i}(x_i - y_i)^2}$$ where $x_i$ and $y_i$ are the $i^{th}$ components of $\vec{x}$ and $\vec{y}$ respectively.

Euclidean distance is an intuitive measure of the distance between two points in space. Unfortunately, this doesn't also translate to visual similarity, as illustrated by Doersch et al. \cite{Doersch2016}. Figure \ref{fig:eucledian_distance_a} is a digit drawn from the MNIST dataset, and Figures \ref{fig:eucledian_distance_b} and \ref{fig:eucledian_distance_c} are attempted reconstructions. Of the reconstructions, Figure \ref{fig:eucledian_distance_c} looks most like the original, but Figure \ref{fig:eucledian_distance_b} is closer in space.\\

\begin{figure}[!htb]
\centering
\minipage{0.32\textwidth}
\centering
  \includegraphics[width=0.8\linewidth]{background/eucledian_distance_a.png}
  \caption{}\label{fig:eucledian_distance_a}
\endminipage\hfill
\minipage{0.32\textwidth}
\centering
  \includegraphics[width=0.8\linewidth]{background/eucledian_distance_c.png}
  \caption{}\label{fig:eucledian_distance_c}
\endminipage\hfill
\minipage{0.32\textwidth}%
\centering
  \includegraphics[width=0.8\linewidth]{background/eucledian_distance_b.png}
  \caption{}\label{fig:eucledian_distance_b}
\endminipage
\end{figure}

This leads to an alternative measure, binary cross-entropy, which gives a much better quantification of how visually similar two images are.

\subsection{Binary Cross-Entropy}
Consider a single black-and-white pixel with probability $p(0) = c$ of being $0$ and $p(1) = 1 - c$ of being $1$. Here $p(x)$ is a probability distribution over the possible pixel values $x \in \{0, 1\}$. Suppose a given model tries to learn the distribution described by $p(x)$, and says that the pixel has probability $q(0) = \hat{c}$ of being $0$ and $q(1) = 1 - \hat{c}$ of being $1$. The model is perfect if it learns the true distribution, that is, if $q(x) = p(x)$ for $x\in\{0,1\}$. We'd like to quantify how similar the distributions $p$ and $q$ are.

This is done by computing the binary cross-entropy between $p$ and $q$, which is defined by $$H(p,q) = -c\log\hat{c} - (1-c)\log(1-\hat{c})$$ To see how we may use this as a similarity measure among images, consider a $1\times1$ image. Normalising this image yields a pixel value in the interval $[0, 1]$, which may now be interpreted as a probability, corresponding to $c$ above. In the normalised reconstructed image, the pixel value corresponds to $\hat{c}$. We simply compute the binary cross-entropy to measure the similarity of these two distributions, and in turn, the similarity of the images themselves! (Note: we could have also assigned the probabilities to $1-y$ and $1-\hat{y}$ by symmetry of binary cross-entropy).

For images larger than $1 \times 1$, we may take the component-wise binary cross-entropy, then, for example, average the components. How the component-wise binary cross-entropies are suitably combined to give a single floating point number will vary from problem to problem.



%
%
%
%
%
\section{Stella}
Video games are becoming increasingly popular in the generation of data sets for machine learning purposes. One reason for this is that they do not inherit many operational drawbacks from real world data, such as noise, the stability of the camera or the observation of rare circumstances (the video game may just be queried for rare cases) \cite{Zsolnai-Feher2016, Richter2016}.


%
%
%
%
%
\section{Arcade Learning Environment}
The Arcade Learning Environment (ALE) is a framework built on top of the Atari
2600 emulator Stella \cite{Bellemare2015}. This library was a suitable choice because:
\begin{itemize}
\item Emulation details are abstracted away from the researcher
\item The same agent can be used for all games, due to its modular design
\item Frames can be saved during game play, which is used to collect training data
\item A Python wrapper for the entire framework is provided, so our agents developed in Keras interact seamlessly
\end{itemize}


%
%
%
%
%
\section{Keras}
Keras is a high-level neural network library written in Python \cite{Chollet2016}. It was a suitable choice because it supports:
\begin{itemize}
\item Convolutional, deconvolutional and pooling layers
\item Lambda functions, which is necessary for sampling in variational autoencoders
\item The creation of custom loss functions, which is necessary when developing new methods
\item Nividia GPUs
\end{itemize}